<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video Rendering Service</title>
  <link rel="stylesheet" href="style.css">
  <style>
    .suggested-prompts {
      list-style-type: none;
      padding: 0;
    }

    .suggested-prompt {
      cursor: pointer;
      padding: 0.5rem;
      border: 1px solid #ccc;
      display: inline-block;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
    }

    .suggested-prompt:hover {
      background-color: #f0f0f0;
    }

    .ellipsis {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 150px;
      display: table-cell;
    }

    button {
      cursor: pointer;
      background: #3498db;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      margin-top: 0.5rem;
      margin-right: 0.5rem;
    }

    td.actions {
      text-align: left;
    }
  </style>
  <style>
    .link-disabled {
      cursor: not-allowed;
      background-color: #f0f0f0;
    }
  </style>

</head>

<body>
  <div id="app">
    <h1>
      Video Rendering Service
    </h1>

    <!-- Form to select visual prompt and provide a custom prompt -->
    <form @submit.prevent="submitForm" class="form-box">
      <div v-show="secret_key && secret_key !== 'please-contact-admin-to-get-one'">
        <label for="prompt">
          Nhập prompt:
        </label>
        <small>
          Cung cấp prompt tùy chỉnh mô tả nội dung bạn muốn tạo.
        </small>
        <textarea id="prompt" v-model="customPrompt" placeholder="Nhập prompt tùy chỉnh" required></textarea>
        <!-- Suggested Prompts Section -->
        <label for="suggested_prompt">
          Suggested Prompts:
        </label>
        <small>
          Hoặc chọn một trong các gợi ý sau:
        </small>
        <ul class="suggested-prompts">
          <li v-for="suggestedPrompt in suggestedPrompts" :key="suggestedPrompt"
            @click="submitCustomPrompt(suggestedPrompt)" class="suggested-prompt"
            :class="{ 'link-disabled': socketIsConnected === false }">
            {{ suggestedPrompt }}
          </li>
        </ul>
      </div>
      <!-- New input field for secret_key -->
      <label for="secret_key">
        <!-- Enter Secret Key: -->
        Nhập Secret Key:
      </label>
      <small>
        Secret key là bắt buộc để xác thực. Liên hệ admin nếu bạn chưa có.
      </small>
      <input type="text" id="secret_key" v-model="secret_key" placeholder="Liên hệ admin để lấy Secret Key" required>

      <button type="submit" class="btn-submit"
        :class="{ 'btn-disabled': (socketIsConnected === false || !secret_key || secret_key === 'please-contact-admin-to-get-one') }">
        Submit
      </button>
    </form>
    <div v-show="!isBackendAPIAvailable" class="form-box">
      <!-- New input field for Backend_API -->
      <label for="backend_api">
        Nhập Backend API:
      </label>
      <small style="color: red;">
        Không thể kết nối với Backend API.
        Backend API là bắt buộc nếu bạn muốn tự động upload và quản lý kênh Youtube.
      </small>
      <input type="text" id="backend_api" v-model="backendAPI" placeholder="Nhập Backend API" style="border: 1px solid red;" />
      <button @click="checkBackendAPIAvailable" class="btn-submit">
        Check Backend API & Save
      </button>
    </div>
    <div v-show="isBackendAPIAvailable" style="color: green;">
      Backend API is available and ready to use.
    </div>
    <div>
      <!-- {{videosInDatabase}} -->
      <table v-show="videosInDatabase.length > 0">
        <tr>
          <th>Job ID</th>
          <th>Video URL</th>
          <th>Status</th>
          <th>
            Platform URL
          </th>
          <th>
            Description
          </th>
          <th>
            Hashtags
          </th>
          <th>
            Title
          </th>
          <th>Actions</th>
        </tr>
        <tr v-for="video in videosInDatabase" :key="video.id">
          <td>{{ video.id }}</td>
          <td>
            <a :href="video.video_url" target="_blank">
              {{ video.video_url }}
            </a>
          </td>
          <td>
            {{ video.status }}
          </td>
          <td class="platform-url">
            <a :href="video.platform_url" target="_blank">
              {{ video.platform_url }}
            </a>
          </td>
          <td class="ellipsis" :title="video.description">
            {{ video.description }}
          </td>
          <td class="ellipsis" :title="video.hashtags">
            {{ video.hashtags }}
          </td>
          <td class="ellipsis" :title="video.title">
            {{ video.title }}
          </td>
          <td class="actions">
            <button @click="deleteVideo(video.id)" style="background-color: red; color: white;">
              Delete
            </button>
            <button @click="uploadVideo(video.id)" style="background-color: green; color: white;"
              v-show="video.status === 'completed'">
              Upload
            </button>
            <button class="btn-disabled" style="background-color: gray; color: white;"
              v-show="video.status === 'uploading'">
              Uploading
            </button>
            <button @click="updateVideoDetails(video.id)" style="background-color: blue; color: white;"
              v-show="video.status === 'uploaded'">
              Update video details
            </button>
          </td>
        </tr>
      </table>
    </div>
    <table v-show="videoDetails.length > 0">
      <tr>
        <th>Prompt</th>
        <th v-for="step in steps" :key="step">{{ step }}</th>
        <th>
          Final Reviewing
        </th>
        <th>
          Exporting
        </th>
      </tr>
      <tr v-for="videoDetail in videoDetails" :key="videoDetail.prompt">
        <td class="wrap">{{ videoDetail.prompt }}</td>
        <td v-for="step in steps" :key="step">
          <!-- {{ videoDetail[step] }} -->
          <div v-for="item in videoDetail[step]" :key="item.id">
            {{ item }}
          </div>
        </td>
        <td>
          <div v-for="item in videoDetail.final_reviewing" :key="item.id">
            {{ item.visual }}
          </div>
        </td>
        <td>
          {{ videoDetail.exporting }}
        </td>
      </tr>
    </table>

    <!-- Notification list -->
    <ul class="notifications">
      <li class="notification">
        Trong khi chờ video được tạo, bạn có thể gửi prompt khác và quá trình tạo video sẽ được thực hiện song song.
        <!-- While waiting for the video to render, you can submit another prompt and it will be rendered concurrently. -->
      </li>
      <li v-for="notification in notifications" :key="notification.id" class="notification">
        <span>{{ notification.message }}</span>

        <!-- Conditionally display video player if video_url exists in the notification -->
        <video v-if="notification.video_url" controls width="100%" style="margin-top: 1rem;"
          onerror="this.style.display='none'">
          <source :src="notification.video_url" type="video/mp4">
          Your browser does not support the video tag.
        </video>
        <a v-if="notification.video_url" :href="notification.video_url" target="_blank">
          <small>
            Click to download the video
          </small>
        </a>
      </li>
    </ul>
  </div>

  <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.5.4/vue.global.prod.min.js"
    integrity="sha512-daXDxACuUMgdw50LypY68sSM7Qksm/pJ207U8xLSv30B9J9YhU3wvHRZotKhBppjPgmatS6Cf2nkNxaImiHNyg=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/dayjs.min.js"
    integrity="sha512-FwNWaxyfy2XlEINoSnZh1JQ5TRRtGow0D6XcmAWmYCRgvqOUTnzCxPc9uF35u5ZEpirk1uhlPVA19tflhvnW1g=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/plugin/duration.min.js"
    integrity="sha512-t0b2NyBypSms8nA81pldWo0mXbfMotsdYgvs4awmbi/GU/25YBNLnXj+I9DAMV7WGZ8+z8wtRolX7zSF2LN8UQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/plugin/relativeTime.min.js"
    integrity="sha512-MVzDPmm7QZ8PhEiqJXKz/zw2HJuv61waxb8XXuZMMs9b+an3LoqOqhOEt5Nq3LY1e4Ipbbd/e+AWgERdHlVgaA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.7.7/axios.min.js"
    integrity="sha512-DdX/YwF5e41Ok+AI81HI8f5/5UsoxCVT9GKYZRIzpLxb8Twz4ZwPPX+jQMwMhNQ9b5+zDEefc+dcvQoPWGNZ3g=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
    dayjs.extend(window.dayjs_plugin_duration);
    dayjs.extend(window.dayjs_plugin_relativeTime);

    let storedBackendUrl = localStorage.getItem('backend_url');
    if (storedBackendUrl) {
      console.log('Stored backend URL:', storedBackendUrl);
    } else {
      localStorage.setItem('backend_url', 'http://localhost:3000');
    }
    let backendURL = localStorage.getItem('backend_url');
    axios.defaults.baseURL = backendURL;

    const controller = {
      async pingBackend() {
        try {
          const response = await axios.get('/ping');
          console.log(response.data);
        } catch (error) {
          console.error(error);
          window.alert('Backend API is not available. Run the backend server and refresh the page. Run `yarn start:dev` to start the backend server.');
        }
      },
      async uploadFile({ url, urlPath, waitForSelector, file }) {
        await this.pingBackend();
        let uploaded = await axios.post('/browser/upload', {
          url,
          urlPath,
          waitForSelector,
          file,
        });

        return uploaded.data;
      },
      async clickElement({ selector, text, times }) {
        await this.pingBackend();
        let clicked = await axios.post('/browser/clickElement', {
          selector,
          text,
          times,
        });

        return clicked.data;
      },
      async getTextContent(selector, find) {
        await this.pingBackend();
        let textContent = await axios.get('/browser/getTextContent?selector=' + encodeURIComponent(selector) + '&find=' + encodeURIComponent(find));

        return textContent.data;
      },
      async typeOnFocused({ selector, matcher, text }) {
        await this.pingBackend();
        let typed = await axios.post('/browser/typeOnFocused', {
          selector,
          matcher,
          text,
        });

        return typed.data;
      },

      async gotoPage({ url }) {
        await this.pingBackend();
        let page = await axios.post('/browser/goto', {
          url,
        });

        return page.data;
      },
      async getPageContent() {
        await this.pingBackend();
        let pageContent = await axios.get('/browser/content');

        return pageContent.data;
      },
    };
    const dbService = {
      openDatabase() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open('videoDatabase', 1);

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('videos')) {
              db.createObjectStore('videos', { keyPath: 'id', autoIncrement: true });
            }
          };

          request.onsuccess = (event) => {
            resolve(event.target.result);
          };

          request.onerror = (event) => {
            reject(event.target.error);
          };
        });
      },

      async createItem(video) {
        const db = await this.openDatabase();
        const transaction = db.transaction(['videos'], 'readwrite');
        const store = transaction.objectStore('videos');
        store.add(video);
        transaction.oncomplete = () => {
          console.log('Video added successfully');
        };
        transaction.onerror = (event) => {
          console.error('Error adding video:', event.target.error);
        };
      },

      async readItem(id) {
        const db = await this.openDatabase();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(['videos'], 'readonly');
          const store = transaction.objectStore('videos');
          const request = store.get(id);

          request.onsuccess = (event) => {
            resolve(event.target.result);
          };

          request.onerror = (event) => {
            reject(event.target.error);
          };
        });
      },

      async editItem(id, updatedVideo) {
        const db = await this.openDatabase();
        const transaction = db.transaction(['videos'], 'readwrite');
        const store = transaction.objectStore('videos');
        const request = store.put({ ...updatedVideo, id });

        transaction.oncomplete = () => {
          console.log('Video updated successfully');
        };

        transaction.onerror = (event) => {
          console.error('Error updating video:', event.target.error);
        };
      },

      async deleteItem(id) {
        const db = await this.openDatabase();
        const transaction = db.transaction(['videos'], 'readwrite');
        const store = transaction.objectStore('videos');
        store.delete(id);

        transaction.oncomplete = () => {
          console.log('Video deleted successfully');
        };

        transaction.onerror = (event) => {
          console.error('Error deleting video:', event.target.error);
        };
      },

      async listItems() {
        const db = await this.openDatabase();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(['videos'], 'readonly');
          const store = transaction.objectStore('videos');
          const request = store.getAll();

          request.onsuccess = (event) => {
            resolve(event.target.result);
          };

          request.onerror = (event) => {
            reject(event.target.error);
          };
        });
      }
    };


    let submittedAt = new Date();
    let baseUrl = 'https://http-distributor-api-apis-production-80.schnworks.com/';
    const app = Vue.createApp({
      data() {
        return {
          backendAPI: backendURL,
          isBackendAPIAvailable: false,
          videosInDatabase: [],
          suggestedPrompts: [
            'Xây dựng bài giảng về sales pipeline. Đối tượng là người đọc không chuyên về lĩnh vực kinh doanh và tiếp thị',
            'Hãy xây dựng bài giảng về Blockchain. Đối tượng là người đọc không chuyên về lĩnh vực công nghệ',
            // 'Giới thiệu tổng quan về công nghệ Blockchain',
            'Hãy giới thiệu thuật toán Obelisk Consensus trong Blockchain. Đối tượng là người đọc không chuyên về lĩnh vực công nghệ (Blockchain)',
            'Các bước để trở thành một indie hacker',
            'Thuyết trình về những ứng dụng của AI trong cuộc sống',
            'Giới thiệu về lịch sử nền văn minh Hy Lạp',
          ],
          notifications: [], // Store notifications reactively
          count: 0,
          socketIsConnected: false,
          socket: null,
          steps: [
            // "writing_down_ideas",
            // "planning_episodes",
            // "defining_target_audience",
            "step_1",
            "step_2",
            "step_3",
            "step_3.1",
            "step_3.2",
            "step_4",
            "step_5.1",
            "step_5.2",
            "step_6",
            "step_7",
            "step_7.2. importing media",
            "step_8",
            // "final reviewing",
            // "exporting",
          ],
          videoDetails: [],
          baseUrl,
          secret_key: 'please-contact-admin-to-get-one', // Default secret key
          selectedVisualPrompt: 'Entrepreneurship', // Store selected visual prompt
          customPrompt: 'Hãy xây dựng bài giảng về indie hacker', // Store user input for prompt
          video_url: '', // Store the video URL
          visualPrompts: [
            'Entrepreneurship',
            'Geometry',
            'Mathematics',
            'Science',
            'History',
            'Art'
          ] // Predefined visual prompts
        };
      },
      created() {
        this.loadVideosFromIndexedDB();
        this.checkBackendAPIAvailable();
      },
      methods: {
        async checkBackendAPIAvailable() {
          try {
            const response = await axios.get(this.backendAPI + '/ping');
            console.log(response.data);
            this.isBackendAPIAvailable = true;
            localStorage.setItem('backend_url', this.backendAPI);
            axios.defaults.baseURL = this.backendAPI;
          } catch (error) {
            console.error(error);
            this.isBackendAPIAvailable = false;
          }
        },
        loadVideosFromIndexedDB() {
          dbService.listItems().then((videos) => {
            videos.forEach((video) => {
              if (this.videosInDatabase.filter((item) => item.id === video.id).length === 0) {
                this.videosInDatabase.push(video);
              }
            });
          });
        },
        async updateVideoDetails(id) {
          const video = await dbService.readItem(id);
          console.log('Updating video details:', video);
          this.videosInDatabase.forEach((video, index) => {
            if (video.id === id) {
              this.videosInDatabase[index] = {
                ...video,
                status: 'updating_details',
              };
            }
          });
          let {
            description,
            hashtags,
            title,
            platform_url: videoUrl,
          } = video;
          let matcher = videoUrl.match(/https:\/\/youtu\.be\/(.*)/);
          let videoId = matcher[1];
          let studioUrl = `https://studio.youtube.com/video/${videoId}/edit`;
          await controller.gotoPage({ url: studioUrl });
          await new Promise((resolve) => setTimeout(resolve, 35_000));
          let pageContent = await controller.getPageContent();
          console.log('Page content:', pageContent);
          let matcherConfirm = 'we need to confirm it';
          while (pageContent.includes(matcherConfirm)) {
            await new Promise((resolve) => setTimeout(resolve, 10_000));
            pageContent = await controller.getPageContent();
          }
          let commonSelector = 'ytcp-form-input-container[focused] #outer.ytcp-form-input-container';
          // await this.typeOnFocused(commonSelector, 'Title (required)', title);
          await controller.typeOnFocused({
            selector: commonSelector,
            matcher: 'Title (required)',
            text: title,
          });
          // await this.typeOnFocused(commonSelector, 'Description', description)
          await controller.typeOnFocused({
            selector: commonSelector,
            matcher: 'Description',
            text: description,
          });

          await controller.clickElement({
            selector: 'button',
            text: 'Show more',
            times: 1,
          });
          await controller.typeOnFocused({
            selector: commonSelector,
            matcher: 'Add tag',
            text: hashtags + ',',
          });

          await controller.clickElement({
            selector: 'ytcp-button[type=filled]',
            text: 'Save',
            times: 1,
          });
          video.status = 'details_updated';
          dbService.editItem(id, video);
          this.syncVideoInDatabase(id);
        },
        syncVideoInDatabase(id) {
          let updatedVideo = dbService.readItem(id);
          this.videosInDatabase.forEach((video, index) => {
            if (video.id === id) {
              this.videosInDatabase.splice(index, 1, updatedVideo);
            }
          });
        },
        async uploadVideo(id) {
          const video = await dbService.readItem(id);
          this.videosInDatabase.forEach((video, index) => {
            if (video.id === id) {
              this.videosInDatabase[index] = {
                ...video,
                status: 'uploading',
              };
            }
          });
          console.log('Uploading video:', video);
          let video_url = video.video_url;
          const result = await controller.uploadFile({
            url: 'https://studio.youtube.com/',
            urlPath: '/videos/upload?d=ud',
            waitForSelector: 'input[name="Filedata"]',
            file: video_url,
          });

          console.log('Result:', result);

          while (true) {
            const pageContent = await controller.getPageContent();
            console.log('Page content:', pageContent);

            await new Promise((resolve) => setTimeout(resolve, 8000));

            if (pageContent.includes('Checks complete. No issues found.')) {
              break;
            }
            let minutesLeft = await controller.getTextContent('span', 'minutes left');
            console.log('Minutes left:', minutesLeft);
            if (minutesLeft.includes('minutes left')) {
              this.videosInDatabase.forEach((video, index) => {
                if (video.id === id) {
                  this.videosInDatabase[index] = {
                    ...video,
                    status: minutesLeft,
                  };
                }
              });
            }
          }

          let textContent = await controller.getTextContent(
            'div',
            'https://youtu.be/',
          );
          // 
          while (true) {
            await new Promise((resolve) => setTimeout(resolve, 12_000));
            let radioLabelText = await controller.getTextContent(
              '#radioLabel',
              'Public',
            );
            console.log('Radio label text:', JSON.stringify({ radioLabelText }));
            if (radioLabelText === 'Public') {
              break;
            }
            await controller.clickElement({
              selector: '#next-button.ytcp-uploads-dialog',
              text: '',
              times: 1,
            });
          }
          // 
          await controller.clickElement({
            selector: '#radioLabel',
            text: 'Public',
            times: 1,
          });
          // 
          await new Promise((resolve) => setTimeout(resolve, 2_000));
          await controller.clickElement({
            selector: '#done-button.ytcp-uploads-dialog',
            text: '',
            times: 1,
          });
          console.log('Text content:', textContent);

          // Update video status and video URL
          video.status = 'uploaded';
          let trimmedTextContent = textContent.replace(/[\n\r]+/g, '').trim();
          let platformUrl = trimmedTextContent;
          video.platform_url = platformUrl;

          dbService.editItem(id, video);
          this.syncVideoInDatabase(id);

          return textContent;
        },
        async deleteVideo(id) {
          dbService.deleteItem(id);
          this.videosInDatabase.forEach((video, index) => {
            if (video.id === id) {
              this.videosInDatabase.splice(index, 1);
            }
          });
        },

        submitCustomPrompt(suggestedPrompt) {
          this.customPrompt = suggestedPrompt;
          this.submitForm();
        },
        appendNotification(message, video_url = null) {
          // const start = dayjs('2023-10-01');
          // const end = dayjs('2023-10-05');
          let start = dayjs(submittedAt);
          let end = dayjs(new Date());
          const humanReadableDiff = dayjs.duration(end.diff(start)).humanize();
          // let notifiedAt = new Date();
          // let timeDiff = notifiedAt - submittedAt;
          this.notifications.unshift({
            // to publish /static/ folder on free public static server
            // You can use Cloudflare Pages, Vercel, Netlify, or GitHub Pages
            id: this.notifications.length + 1,
            message: '[' + humanReadableDiff + '] ' + message,
            video_url,
          });
        },
        sendJobCompletion() {
          const postData = {
            'job_id': '12345',
            'status': 'complete',
            'video_url': 'https://example.com/video.m3u8',
            'thumbnail_url': 'https://example.com/thumbnail.jpg',
            'message': 'Video rendering job complete',
            'duration': 60,
            'resolution': '1080p',
            'format': 'mp4',
            'secret_key': this.secret_key
          };

          setTimeout(() => {
            this.sendPostRequest(this.baseUrl, postData);
          }, 200);
        },
        sendPostRequest(url, data) {
          const xhr = new XMLHttpRequest();
          xhr.open('POST', url, true);
          xhr.setRequestHeader('Content-Type', 'application/json');
          xhr.send(JSON.stringify(data));

          xhr.onreadystatechange = () => {
            if (xhr.readyState === 4 && xhr.status === 200) {
              console.log(xhr.responseText);
            }
          };
        },
        submitForm() {
          submittedAt = new Date();

          // Save the secret_key to localStorage
          localStorage.setItem('secret_key', this.secret_key);

          // Send subscribe message with user-entered secret_key
          this.socket.emit('subscribe', { secret_key: this.secret_key });

          const postData = {
            // 'visual_prompt': this.selectedVisualPrompt,
            'prompt': this.customPrompt,
            'secret_key': this.secret_key
          };

          this.sendPostRequest(this.baseUrl.replace(/\/$/, '') + '/api/v1/render-video', postData);

          this.customPrompt = '';
        },
        updateGanttChart(message) {
          let {
            status,
          } = message;
          // console.log(message);
          if (this.videoDetails.filter((item) => item.prompt === message.prompt).length === 0) {
            this.videoDetails.push({
              prompt: message.prompt,
              ...this.$data.steps.reduce((acc, step) => {
                acc[step] = '';
                return acc;
              }, {}),
              final_reviewing: [],
              exporting: '',
            });
          }
          //
          for (let i = 0; i < this.videoDetails.length; i++) {
            if (this.videoDetails[i].prompt === message.prompt) {
              if (status.startsWith('final reviewing')) {
                let matcher = /final reviewing (\d+) out of (\d+) (\d+)\/(\d+)/;
                let match = matcher.exec(message.status);
                // console.log(match, status);
                if (match) {
                  let [_, id, total1, current, total] = match;
                  let final_reviewing_item = this.videoDetails[i].final_reviewing
                    .filter((item) => item.id === id)[0];
                  // console.log(final_reviewing_item);
                  // console.log(typeof final_reviewing_item);
                  if (typeof final_reviewing_item === 'undefined') {
                    this.videoDetails[i].final_reviewing.push({
                      total: 0,
                      current: 0,
                      id: id,
                      visual: '',
                    });
                  }
                  //
                  for (let j = 0; j < this.videoDetails[i].final_reviewing.length; j++) {
                    if (this.videoDetails[i].final_reviewing[j].id === id) {
                      this.videoDetails[i].final_reviewing[j].total = total;
                      this.videoDetails[i].final_reviewing[j].current = current;
                      this.videoDetails[i].final_reviewing[j].visual = '✅'.repeat(current) + '⏳'.repeat(total - current);
                      // console.log('Final reviewing', this.videoDetails[i].final_reviewing[j]);
                      break;
                    }
                  }
                }
              } else {
                if (status.startsWith('exporting')) {
                  // exporting 2/5
                  let matcher = /exporting (\d+)\/(\d+)/;
                  let match = matcher.exec(message.status);
                  console.log(match, status);
                  if (match) {
                    let [_, current, total] = match;
                    this.videoDetails[i].exporting = '✅'.repeat(current) + '⏳'.repeat(total - current);
                  }
                } else {
                  if ('' === this.videoDetails[i][status]) {
                    this.videoDetails[i][status] = ['✅'];
                  } else {
                    console.log(this.videoDetails[i][status], status);
                    if (this.steps.includes(status)) {
                      this.videoDetails[i][status] = this.videoDetails[i][status].concat(['✅']);
                    }
                  }
                }
              }
              break;
            }
          }
        },
        addVideoToIndexedDB(video) {
          this.createItem(video);
          this.loadVideosFromIndexedDB();
        },
        setupWebSocket() {
          this.socket = io(this.baseUrl);

          // Send subscribe message with user-entered secret_key
          this.socket.emit('subscribe', { secret_key: this.secret_key });

          this.socket.on('subscription_success', (data) => {
            this.appendNotification("Subscription Success: " + data.message);
          });

          this.socket.on('subscription_error', (data) => {
            this.appendNotification("Subscription Error: " + data.message);
          });

          let ct = this;
          this.socket.on('job_complete', (data) => {
            let {
              prompt: prompt,
              message, job_id, video_url, thumbnail_url, duration, resolution, format, secret_key, status
            } = data.message;
            this.updateGanttChart(data.message);

            this.appendNotification("- Status: " + status);
            if (status === 'completed') {
              console.log(data.message);
              let matcher = /Original prompt is: (.+). Description: (.+). Hashtags: (.+). Title is: (.+)$/;
              let match = matcher.exec(data.message.message);
              console.log(match);
              if (!match) {
                console.error('Invalid message:', data.message.message);
                return;
              }
              let [, , description, hashtags, title] = match;
              this.appendNotification("- Description: " + description);
              this.appendNotification("- Hashtags: " + hashtags);
              this.appendNotification("- Title: " + title);
              this.appendNotification("- Prompt: " + prompt);
              this.appendNotification("- Job ID: " + job_id);
              this.appendNotification("- Video rendering job complete.");
              this.appendNotification("- Secret Key: " + secret_key);
              this.appendNotification("- Thumbnail URL: " + thumbnail_url);
              this.appendNotification("- Duration: " + duration);
              this.appendNotification("- Resolution: " + resolution);
              this.appendNotification("- Format: " + format);

              if (video_url) {
                // Add video data to IndexedDB
                let videoUrl = baseUrl + video_url.replace(/^\/+/, '');
                ct.addVideoToIndexedDB({
                  description,
                  hashtags,
                  title,
                  job_id,
                  video_url: videoUrl,
                  thumbnail_url,
                  duration,
                  resolution,
                  format,
                  secret_key,
                  status
                });
                this.appendNotification("- Video is ready to play!", videoUrl);
              }
            } else {
              if (status === 'partial_completed') {
                if (video_url) {
                  this.appendNotification("- Bạn có thể xem trước một phần video, toàn bộ video sẽ được cập nhật sau!", baseUrl + video_url.replace(/^\/+/, ''));
                }
              }
            }
          });

          this.socket.on('notification', (data) => {
            this.socketIsConnected = true;
            // if (this.count === 0) {
            // const postData = {
            //   'visual_prompt': this.selectedVisualPrompt || 'Mathematics',
            //   'prompt': this.customPrompt,
            //   'secret_key': this.secret_key
            // };

            // this.sendPostRequest(this.baseUrl.replace(/\/$/, '') + '/api/v1/render-video', postData);

            // if (this.baseUrl.startsWith('http:')) {
            //   this.sendJobCompletion();
            // }
            // }
            this.count++;
            this.appendNotification(data.message);
          });
        }
      },
      mounted() {
        const storedSecretKey = localStorage.getItem('secret_key');
        if (storedSecretKey) {
          this.secret_key = storedSecretKey;
        }

        let ct = this;
        setTimeout(() => {
          ct.setupWebSocket();
        }, 3e3);
      }
    });

    app.mount('#app');
  </script>
</body>

</html>