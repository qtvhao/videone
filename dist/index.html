<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video Rendering Service</title>
  <link rel="stylesheet" href="style.css">
  <style>
    .suggested-prompts {
      list-style-type: none;
      padding: 0;
    }

    .suggested-prompt {
      cursor: pointer;
      padding: 0.5rem;
      border: 1px solid #ccc;
      display: inline-block;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
    }

    .suggested-prompt:hover {
      background-color: #f0f0f0;
    }

    .ellipsis {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 280px;
      display: table-cell;
    }

    button {
      cursor: pointer;
      background: #3498db;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      margin-top: 0.5rem;
      margin-right: 0.5rem;
    }
    td.actions {
      text-align: left;
    }
  </style>
  <style>
    .link-disabled {
      cursor: not-allowed;
      background-color: #f0f0f0;
    }
  </style>

</head>

<body>
  <div id="app">
    <h1>
      Video Rendering Service
    </h1>

    <!-- Form to select visual prompt and provide a custom prompt -->
    <form @submit.prevent="submitForm">
      <div v-show="secret_key && secret_key !== 'please-contact-admin-to-get-one'">
        <label for="prompt">
          Nhập prompt:
        </label>
        <small>
          Cung cấp prompt tùy chỉnh mô tả nội dung bạn muốn tạo.
        </small>
        <textarea id="prompt" v-model="customPrompt" placeholder="Nhập prompt tùy chỉnh" required></textarea>
        <!-- Suggested Prompts Section -->
        <label for="suggested_prompt">
          Suggested Prompts:
        </label>
        <small>
          Hoặc chọn một trong các gợi ý sau:
        </small>
        <ul class="suggested-prompts">
          <li v-for="suggestedPrompt in suggestedPrompts" :key="suggestedPrompt"
            @click="submitCustomPrompt(suggestedPrompt)" class="suggested-prompt"
            :class="{ 'link-disabled': socketIsConnected === false }">
            {{ suggestedPrompt }}
          </li>
        </ul>
      </div>
      <!-- New input field for secret_key -->
      <label for="secret_key">
        <!-- Enter Secret Key: -->
        Nhập Secret Key:
      </label>
      <small>
        Secret key là bắt buộc để xác thực. Liên hệ admin nếu bạn chưa có.
      </small>
      <input type="text" id="secret_key" v-model="secret_key" placeholder="Liên hệ admin để lấy Secret Key" required>

      <button type="submit" class="btn-submit"
        :class="{ 'btn-disabled': (socketIsConnected === false || !secret_key || secret_key === 'please-contact-admin-to-get-one') }">
        Submit
      </button>
    </form>
    <div>
      <!-- {{videosInDatabase}} -->
      <table v-show="videosInDatabase.length > 0">
        <tr>
          <th>Job ID</th>
          <th>Video URL</th>
          <th>Status</th>
          <th>
            Platform URL
          </th>
          <th>Actions</th>
        </tr>
        <tr v-for="video in videosInDatabase" :key="video.id">
          <td>{{ video.id }}</td>
          <td>
            <a :href="video.video_url" target="_blank">
              {{ video.video_url }}
            </a>
          </td>
          <td>
            {{ video.status }}
          </td>
          <td class="platform-url">
            <a :href="video.platform_url" target="_blank">
              {{ video.platform_url }}
            </a>
          </td>
          <td class="actions">
            <button @click="deleteVideo(video.id)" style="background-color: red; color: white;">
              Delete
            </button>
            <button @click="uploadVideo(video.id)" style="background-color: green; color: white;" v-show="video.status === 'completed'">
              Upload
            </button>
          </td>
        </tr>
      </table>
    </div>
    <table v-show="videoDetails.length > 0">
      <tr>
        <th>Prompt</th>
        <th v-for="step in steps" :key="step">{{ step }}</th>
        <th>
          Final Reviewing
        </th>
        <th>
          Exporting
        </th>
      </tr>
      <tr v-for="videoDetail in videoDetails" :key="videoDetail.prompt">
        <td class="ellipsis">{{ videoDetail.prompt }}</td>
        <td v-for="step in steps" :key="step">
          <!-- {{ videoDetail[step] }} -->
          <div v-for="item in videoDetail[step]" :key="item.id">
            {{ item }}
          </div>
        </td>
        <td>
          <div v-for="item in videoDetail.final_reviewing" :key="item.id">
            {{ item.visual }}
          </div>
        </td>
        <td>
          {{ videoDetail.exporting }}
        </td>
      </tr>
    </table>

    <!-- Notification list -->
    <ul class="notifications">
      <li class="notification">
        Trong khi chờ video được tạo, bạn có thể gửi prompt khác và quá trình tạo video sẽ được thực hiện song song.
        <!-- While waiting for the video to render, you can submit another prompt and it will be rendered concurrently. -->
      </li>
      <li v-for="notification in notifications" :key="notification.id" class="notification">
        <span>{{ notification.message }}</span>

        <!-- Conditionally display video player if video_url exists in the notification -->
        <video v-if="notification.video_url" controls width="100%" style="margin-top: 1rem;"
          onerror="this.style.display='none'">
          <source :src="notification.video_url" type="video/mp4">
          Your browser does not support the video tag.
        </video>
        <a v-if="notification.video_url" :href="notification.video_url" target="_blank">
          <small>
            Click to download the video
          </small>
        </a>
      </li>
    </ul>
  </div>

  <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.5.4/vue.global.prod.min.js"
    integrity="sha512-daXDxACuUMgdw50LypY68sSM7Qksm/pJ207U8xLSv30B9J9YhU3wvHRZotKhBppjPgmatS6Cf2nkNxaImiHNyg=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/dayjs.min.js"
    integrity="sha512-FwNWaxyfy2XlEINoSnZh1JQ5TRRtGow0D6XcmAWmYCRgvqOUTnzCxPc9uF35u5ZEpirk1uhlPVA19tflhvnW1g=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/plugin/duration.min.js"
    integrity="sha512-t0b2NyBypSms8nA81pldWo0mXbfMotsdYgvs4awmbi/GU/25YBNLnXj+I9DAMV7WGZ8+z8wtRolX7zSF2LN8UQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/plugin/relativeTime.min.js"
    integrity="sha512-MVzDPmm7QZ8PhEiqJXKz/zw2HJuv61waxb8XXuZMMs9b+an3LoqOqhOEt5Nq3LY1e4Ipbbd/e+AWgERdHlVgaA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.7.7/axios.min.js"
    integrity="sha512-DdX/YwF5e41Ok+AI81HI8f5/5UsoxCVT9GKYZRIzpLxb8Twz4ZwPPX+jQMwMhNQ9b5+zDEefc+dcvQoPWGNZ3g=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
    dayjs.extend(window.dayjs_plugin_duration);
    dayjs.extend(window.dayjs_plugin_relativeTime);

    let storedBackendUrl = localStorage.getItem('backend_url');
    if (storedBackendUrl) {
      console.log('Stored backend URL:', storedBackendUrl);
    } else {
      localStorage.setItem('backend_url', 'http://localhost:3000');
    }
    axios.defaults.baseURL = localStorage.getItem('backend_url');

    const controller = {
      async pingBackend() {
        try {
          const response = await axios.get('/ping');
          console.log(response.data);
        } catch (error) {
          console.error(error);
          let backendUrl = window.prompt('Please enter the correct backend URL:', 'http://localhost:3000');
          if (backendUrl) {
            axios.defaults.baseURL = backendUrl;
            localStorage.setItem('backend_url', backendUrl);
          }
        }
      },
      async uploadFile({ url, urlPath, waitForSelector, file }) {
        await this.pingBackend();
        let uploaded = await axios.post('/browser/upload', {
          url,
          urlPath,
          waitForSelector,
          file,
        });

        return uploaded.data;
      },
      async clickElement({ selector, text, times }) {
        await this.pingBackend();
        let clicked = await axios.post('/browser/clickElement', {
          selector,
          text,
          times,
        });

        return clicked.data;
      },
      async getTextContent(selector, find) {
        await this.pingBackend();
        let textContent = await axios.get('/browser/getTextContent?selector=' + encodeURIComponent(selector) + '&find=' + encodeURIComponent(find));

        return textContent.data;
      },
      async getPageContent() {
        await this.pingBackend();
        let pageContent = await axios.get('/browser/content');

        return pageContent.data;
      },
    };

    let submittedAt = new Date();
    let baseUrl = 'https://http-distributor-api-apis-production-80.schnworks.com/';
    const app = Vue.createApp({
      data() {
        return {
          videosInDatabase: [],
          suggestedPrompts: [
            'Xây dựng bài giảng về sales pipeline. Đối tượng là người đọc không chuyên về lĩnh vực kinh doanh và tiếp thị',
            'Hãy xây dựng bài giảng về Blockchain. Đối tượng là người đọc không chuyên về lĩnh vực công nghệ',
            // 'Giới thiệu tổng quan về công nghệ Blockchain',
            'Hãy giới thiệu thuật toán Obelisk Consensus trong Blockchain. Đối tượng là người đọc không chuyên về lĩnh vực công nghệ (Blockchain)',
            'Các bước để trở thành một indie hacker',
            'Thuyết trình về những ứng dụng của AI trong cuộc sống',
            'Giới thiệu về lịch sử nền văn minh Hy Lạp',
          ],
          notifications: [], // Store notifications reactively
          count: 0,
          socketIsConnected: false,
          socket: null,
          steps: [
            // "writing_down_ideas",
            // "planning_episodes",
            // "defining_target_audience",
            "step_1",
            "step_2",
            "step_3",
            "step_3.1",
            "step_3.2",
            "step_4",
            "step_5.1",
            "step_5.2",
            "step_6",
            "step_7",
            "step_7.2. importing media",
            "step_8",
            // "final reviewing",
            // "exporting",
          ],
          videoDetails: [],
          baseUrl,
          secret_key: 'please-contact-admin-to-get-one', // Default secret key
          selectedVisualPrompt: 'Entrepreneurship', // Store selected visual prompt
          customPrompt: 'Hãy xây dựng bài giảng về indie hacker', // Store user input for prompt
          video_url: '', // Store the video URL
          visualPrompts: [
            'Entrepreneurship',
            'Geometry',
            'Mathematics',
            'Science',
            'History',
            'Art'
          ] // Predefined visual prompts
        };
      },
      created() {
        this.loadVideosFromIndexedDB();
      },
      methods: {
        loadVideosFromIndexedDB() {
          this.listItems().then((videos) => {
            videos.forEach((video) => {
              if (this.videosInDatabase.filter((item) => item.id === video.id).length === 0) {
                this.videosInDatabase.push(video);
              }
            });
          });
        },
        // Open Database
        openDatabase() {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open('videoDatabase', 1);

            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              if (!db.objectStoreNames.contains('videos')) {
                db.createObjectStore('videos', { keyPath: 'id', autoIncrement: true });
              }
            };

            request.onsuccess = (event) => {
              resolve(event.target.result);
            };

            request.onerror = (event) => {
              reject(event.target.error);
            };
          });
        },

        // Create Item
        async createItem(video) {
          const db = await this.openDatabase();
          const transaction = db.transaction(['videos'], 'readwrite');
          const store = transaction.objectStore('videos');
          store.add(video);
          transaction.oncomplete = () => {
            console.log('Video added successfully');
          };
          transaction.onerror = (event) => {
            console.error('Error adding video:', event.target.error);
          };
        },

        // Read Item
        async readItem(id) {
          const db = await this.openDatabase();
          return new Promise((resolve, reject) => {
            const transaction = db.transaction(['videos'], 'readonly');
            const store = transaction.objectStore('videos');
            const request = store.get(id);

            request.onsuccess = (event) => {
              resolve(event.target.result);
            };

            request.onerror = (event) => {
              reject(event.target.error);
            };
          });
        },

        // Edit Item
        async editItem(id, updatedVideo) {
          const db = await this.openDatabase();
          const transaction = db.transaction(['videos'], 'readwrite');
          const store = transaction.objectStore('videos');
          const request = store.put({ ...updatedVideo, id });

          transaction.oncomplete = () => {
            console.log('Video updated successfully');
          };

          transaction.onerror = (event) => {
            console.error('Error updating video:', event.target.error);
          };
          this.videosInDatabase.forEach((video, index) => {
            if (video.id === id) {
              this.videosInDatabase.splice(index, 1, updatedVideo);
            }
          });
        },

        async uploadVideo(id) {
          const video = await this.readItem(id);
          console.log('Uploading video:', video);
          let video_url = video.video_url;
          const result = await controller.uploadFile({
            url: 'https://studio.youtube.com/',
            urlPath: '/videos/upload?d=ud',
            waitForSelector: 'input[name="Filedata"]',
            file: video_url,
          });

          console.log('Result:', result);

          while (true) {
            const pageContent = await controller.getPageContent();
            console.log('Page content:', pageContent);

            await new Promise((resolve) => setTimeout(resolve, 8000));

            if (pageContent.includes('Checks complete. No issues found.')) {
              break;
            }
          }

          let textContent = await controller.getTextContent(
            'div',
            'https://youtu.be/',
          );
          // 
          while (true) {
            await new Promise((resolve) => setTimeout(resolve, 12_000));
            let radioLabelText = await controller.getTextContent(
              '#radioLabel',
              'Public',
            );
            console.log('Radio label text:', JSON.stringify({ radioLabelText }));
            if (radioLabelText === 'Public') {
              break;
            }
            await controller.clickElement({
              selector: '#next-button.ytcp-uploads-dialog',
              text: '',
              times: 1,
            });
          }
          // 
          await controller.clickElement({
            selector: '#radioLabel',
            text: 'Public',
            times: 1,
          });
          // 
          await new Promise((resolve) => setTimeout(resolve, 2_000));
          await controller.clickElement({
            selector: '#done-button.ytcp-uploads-dialog',
            text: '',
            times: 1,
          });
          console.log('Text content:', textContent);

          // Update video status and video URL
          video.status = 'uploaded';
          let trimmedTextContent = textContent.replace(/[\n\r]+/g, '').trim();
          let platformUrl = trimmedTextContent;
          video.platform_url = platformUrl;

          this.editItem(id, video);
          return textContent;
        },
        async deleteVideo(id) {
          this.deleteItem(id);
          this.videosInDatabase.forEach((video, index) => {
            if (video.id === id) {
              this.videosInDatabase.splice(index, 1);
            }
          });
        },
        // Delete Item
        async deleteItem(id) {
          const db = await this.openDatabase();
          const transaction = db.transaction(['videos'], 'readwrite');
          const store = transaction.objectStore('videos');
          store.delete(id);

          transaction.oncomplete = () => {
            console.log('Video deleted successfully');
          };

          transaction.onerror = (event) => {
            console.error('Error deleting video:', event.target.error);
          };
        },

        // List Items
        async listItems() {
          const db = await this.openDatabase();
          return new Promise((resolve, reject) => {
            const transaction = db.transaction(['videos'], 'readonly');
            const store = transaction.objectStore('videos');
            const request = store.getAll();

            request.onsuccess = (event) => {
              resolve(event.target.result);
            };

            request.onerror = (event) => {
              reject(event.target.error);
            };
          });
        },
        submitCustomPrompt(suggestedPrompt) {
          this.customPrompt = suggestedPrompt;
          this.submitForm();
        },
        appendNotification(message, video_url = null) {
          // const start = dayjs('2023-10-01');
          // const end = dayjs('2023-10-05');
          let start = dayjs(submittedAt);
          let end = dayjs(new Date());
          const humanReadableDiff = dayjs.duration(end.diff(start)).humanize();
          // let notifiedAt = new Date();
          // let timeDiff = notifiedAt - submittedAt;
          this.notifications.unshift({
            // to publish /static/ folder on free public static server
            // You can use Cloudflare Pages, Vercel, Netlify, or GitHub Pages
            id: this.notifications.length + 1,
            message: '[' + humanReadableDiff + '] ' + message,
            video_url,
          });
        },
        sendJobCompletion() {
          const postData = {
            'job_id': '12345',
            'status': 'complete',
            'video_url': 'https://example.com/video.m3u8',
            'thumbnail_url': 'https://example.com/thumbnail.jpg',
            'message': 'Video rendering job complete',
            'duration': 60,
            'resolution': '1080p',
            'format': 'mp4',
            'secret_key': this.secret_key
          };

          setTimeout(() => {
            this.sendPostRequest(this.baseUrl, postData);
          }, 200);
        },
        sendPostRequest(url, data) {
          const xhr = new XMLHttpRequest();
          xhr.open('POST', url, true);
          xhr.setRequestHeader('Content-Type', 'application/json');
          xhr.send(JSON.stringify(data));

          xhr.onreadystatechange = () => {
            if (xhr.readyState === 4 && xhr.status === 200) {
              console.log(xhr.responseText);
            }
          };
        },
        submitForm() {
          submittedAt = new Date();

          // Save the secret_key to localStorage
          localStorage.setItem('secret_key', this.secret_key);

          // Send subscribe message with user-entered secret_key
          this.socket.emit('subscribe', { secret_key: this.secret_key });

          const postData = {
            // 'visual_prompt': this.selectedVisualPrompt,
            'prompt': this.customPrompt,
            'secret_key': this.secret_key
          };

          this.sendPostRequest(this.baseUrl.replace(/\/$/, '') + '/api/v1/render-video', postData);

          this.customPrompt = '';
        },
        updateGanttChart(message) {
          let {
            status,
          } = message;
          // console.log(message);
          if (this.videoDetails.filter((item) => item.prompt === message.prompt).length === 0) {
            this.videoDetails.push({
              prompt: message.prompt,
              ...this.$data.steps.reduce((acc, step) => {
                acc[step] = '';
                return acc;
              }, {}),
              final_reviewing: [],
              exporting: '',
            });
          }
          //
          for (let i = 0; i < this.videoDetails.length; i++) {
            if (this.videoDetails[i].prompt === message.prompt) {
              if (status.startsWith('final reviewing')) {
                let matcher = /final reviewing (\d+) out of (\d+) (\d+)\/(\d+)/;
                let match = matcher.exec(message.status);
                // console.log(match, status);
                if (match) {
                  let [_, id, total1, current, total] = match;
                  let final_reviewing_item = this.videoDetails[i].final_reviewing
                    .filter((item) => item.id === id)[0];
                  // console.log(final_reviewing_item);
                  // console.log(typeof final_reviewing_item);
                  if (typeof final_reviewing_item === 'undefined') {
                    this.videoDetails[i].final_reviewing.push({
                      total: 0,
                      current: 0,
                      id: id,
                      visual: '',
                    });
                  }
                  //
                  for (let j = 0; j < this.videoDetails[i].final_reviewing.length; j++) {
                    if (this.videoDetails[i].final_reviewing[j].id === id) {
                      this.videoDetails[i].final_reviewing[j].total = total;
                      this.videoDetails[i].final_reviewing[j].current = current;
                      this.videoDetails[i].final_reviewing[j].visual = '✅'.repeat(current) + '⏳'.repeat(total - current);
                      // console.log('Final reviewing', this.videoDetails[i].final_reviewing[j]);
                      break;
                    }
                  }
                }
              } else {
                if (status.startsWith('exporting')) {
                  // exporting 2/5
                  let matcher = /exporting (\d+)\/(\d+)/;
                  let match = matcher.exec(message.status);
                  console.log(match, status);
                  if (match) {
                    let [_, current, total] = match;
                    this.videoDetails[i].exporting = '✅'.repeat(current) + '⏳'.repeat(total - current);
                  }
                } else {
                  if ('' === this.videoDetails[i][status]) {
                    this.videoDetails[i][status] = ['✅'];
                  } else {
                    console.log(this.videoDetails[i][status], status);
                    if (this.steps.includes(status)) {
                      this.videoDetails[i][status] = this.videoDetails[i][status].concat(['✅']);
                    }
                  }
                }
              }
              break;
            }
          }
        },
        addVideoToIndexedDB(video) {
          this.createItem(video);
          this.loadVideosFromIndexedDB();
        },
        setupWebSocket() {
          this.socket = io(this.baseUrl);

          // Send subscribe message with user-entered secret_key
          this.socket.emit('subscribe', { secret_key: this.secret_key });

          this.socket.on('subscription_success', (data) => {
            this.appendNotification("Subscription Success: " + data.message);
          });

          this.socket.on('subscription_error', (data) => {
            this.appendNotification("Subscription Error: " + data.message);
          });

          let ct = this;
          this.socket.on('job_complete', (data) => {
            let {
              prompt: prompt,
              message, job_id, video_url, thumbnail_url, duration, resolution, format, secret_key, status
            } = data.message;
            this.updateGanttChart(data.message);

            this.appendNotification("- Status: " + status);
            if (status === 'completed') {
              console.log(data.message);
              let matcher = /Original prompt is: (.+). Description: (.+). Hashtags: (.+). Title is: (.+)$/;
              let match = matcher.exec(data.message.message);
              console.log(match);
              let [,, description, hashtags] = match;
              this.appendNotification("- Description: " + description);
              this.appendNotification("- Hashtags: " + hashtags);
              this.appendNotification("- Prompt: " + prompt);
              this.appendNotification("- Job ID: " + job_id);
              this.appendNotification("- Video rendering job complete.");
              this.appendNotification("- Secret Key: " + secret_key);
              this.appendNotification("- Thumbnail URL: " + thumbnail_url);
              this.appendNotification("- Duration: " + duration);
              this.appendNotification("- Resolution: " + resolution);
              this.appendNotification("- Format: " + format);

              if (video_url) {
                // Add video data to IndexedDB
                let videoUrl = baseUrl + video_url.replace(/^\/+/, '');
                ct.addVideoToIndexedDB({
                  description,
                  hashtags,
                  job_id,
                  video_url: videoUrl,
                  thumbnail_url,
                  duration,
                  resolution,
                  format,
                  secret_key,
                  status
                });
                this.appendNotification("- Video is ready to play!", videoUrl);
              }
            } else {
              if (status === 'partial_completed') {
                if (video_url) {
                  this.appendNotification("- Bạn có thể xem trước một phần video, toàn bộ video sẽ được cập nhật sau!", baseUrl + video_url.replace(/^\/+/, ''));
                }
              }
            }
          });

          this.socket.on('notification', (data) => {
            this.socketIsConnected = true;
            // if (this.count === 0) {
            // const postData = {
            //   'visual_prompt': this.selectedVisualPrompt || 'Mathematics',
            //   'prompt': this.customPrompt,
            //   'secret_key': this.secret_key
            // };

            // this.sendPostRequest(this.baseUrl.replace(/\/$/, '') + '/api/v1/render-video', postData);

            // if (this.baseUrl.startsWith('http:')) {
            //   this.sendJobCompletion();
            // }
            // }
            this.count++;
            this.appendNotification(data.message);
          });
        }
      },
      mounted() {
        const storedSecretKey = localStorage.getItem('secret_key');
        if (storedSecretKey) {
          this.secret_key = storedSecretKey;
        }

        let ct = this;
        setTimeout(() => {
          ct.setupWebSocket();
        }, 3e3);
      }
    });

    app.mount('#app');
  </script>
</body>

</html>